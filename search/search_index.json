{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#write-a-thing","title":"Write A Thing","text":"<p>Use LLMs to help you write your things.</p> <p> </p> <p>Developer:</p> <ul> <li>Dan Saattrup Nielsen (dan.nielsen@alexandra.dk)</li> </ul>"},{"location":"#setup","title":"Setup","text":""},{"location":"#installation","title":"Installation","text":"<ol> <li>Run <code>make install</code>, which sets up a virtual environment and all Python dependencies therein.</li> <li>Run <code>source .venv/bin/activate</code> to activate the virtual environment.</li> <li>(Optional) Run <code>make install-pre-commit</code>, which installs pre-commit hooks for linting, formatting and type checking.</li> </ol>"},{"location":"#adding-and-removing-packages","title":"Adding and Removing Packages","text":"<p>To install new PyPI packages, run: <pre><code>uv add &lt;package-name&gt;\n</code></pre></p> <p>To remove them again, run: <pre><code>uv remove &lt;package-name&gt;\n</code></pre></p> <p>To show all installed packages, run: <pre><code>uv pip list\n</code></pre></p>"},{"location":"#all-built-in-commands","title":"All Built-in Commands","text":"<p>The project includes the following convenience commands:</p> <ul> <li><code>make install</code>: Install the project and its dependencies in a virtual environment.</li> <li><code>make install-pre-commit</code>: Install pre-commit hooks for linting, formatting and type checking.</li> <li><code>make lint</code>: Lint the code using <code>ruff</code>.</li> <li><code>make format</code>: Format the code using <code>ruff</code>.</li> <li><code>make type-check</code>: Type check the code using <code>mypy</code>.</li> <li><code>make test</code>: Run tests using <code>pytest</code> and update the coverage badge in the readme.</li> <li><code>make docker</code>: Build a Docker image and run the Docker container.</li> <li><code>make docs</code>: View documentation locally in a browser.</li> <li><code>make publish-docs</code>: Publish documentation to GitHub Pages.</li> <li><code>make tree</code>: Show the project structure as a tree.</li> </ul>"},{"location":"#a-word-on-modules-and-scripts","title":"A Word on Modules and Scripts","text":"<p>In the <code>src</code> directory there are two subdirectories, <code>write_a_thing</code> and <code>scripts</code>. This is a brief explanation of the differences between the two.</p>"},{"location":"#modules","title":"Modules","text":"<p>All Python files in the <code>write_a_thing</code> directory are modules internal to the project package. Examples here could be a general data loading script, a definition of a model, or a training function. Think of modules as all the building blocks of a project.</p> <p>When a module is importing functions/classes from other modules we use the relative import notation - here's an example:</p> <pre><code>from .other_module import some_function\n</code></pre>"},{"location":"#scripts","title":"Scripts","text":"<p>Python files in the <code>scripts</code> folder are scripts, which are short code snippets that are external to the project package, and which is meant to actually run the code. As such, only scripts will be called from the terminal. An analogy here is that the internal <code>numpy</code> code are all modules, but the Python code you write where you import some <code>numpy</code> functions and actually run them, that a script.</p> <p>When importing module functions/classes when you're in a script, you do it like you would normally import from any other package:</p> <pre><code>from write_a_thing import some_function\n</code></pre> <p>Note that this is also how we import functions/classes in tests, since each test Python file is also a Python script, rather than a module.</p>"},{"location":"#features","title":"Features","text":""},{"location":"#docker-setup","title":"Docker Setup","text":"<p>A Dockerfile is included in the new repositories, which by default runs <code>src/scripts/main.py</code>. You can build the Docker image and run the Docker container by running <code>make docker</code>.</p>"},{"location":"#automatic-documentation","title":"Automatic Documentation","text":"<p>Run <code>make docs</code> to create the documentation in the <code>docs</code> folder, which is based on your docstrings in your code. You can publish this documentation to Github Pages by running <code>make publish-docs</code>. To add more manual documentation pages, simply add more Markdown files to the <code>docs</code> directory; this will automatically be included in the documentation.</p>"},{"location":"#automatic-test-coverage-calculation","title":"Automatic Test Coverage Calculation","text":"<p>Run <code>make test</code> to test your code, which also updates the \"coverage badge\" in the README, showing you how much of your code base that is currently being tested.</p>"},{"location":"#continuous-integration","title":"Continuous Integration","text":"<p>Github CI pipelines are included in the repo, running all the tests in the <code>tests</code> directory, as well as building online documentation, if Github Pages has been enabled for the repository (can be enabled on Github in the repository settings).</p>"},{"location":"#code-spaces","title":"Code Spaces","text":"<p>Code Spaces is a new feature on Github, that allows you to develop on a project completely in the cloud, without having to do any local setup at all. This repo comes included with a configuration file for running code spaces on Github. When hosted on <code>alexandrainst/write_a_thing</code> then simply press the <code>&lt;&gt; Code</code> button and add a code space to get started, which will open a VSCode window directly in your browser.</p>"},{"location":"api/write_a_thing/","title":"write_a_thing","text":"write_a_thing<p> source package write_a_thing </p> <p>Use LLMs to help you write your things.</p> <p> Functions </p> <ul> <li> <p>write \u2014 Write a thing using LLMs and store it as a Word document.</p> </li> </ul> <p> source write(prompt: str, file_paths: list[Path], model: str) \u2192 str </p> <p>Write a thing using LLMs and store it as a Word document.</p> <p> Parameters </p> <ul> <li> <p>prompt :  str \u2014 The prompt to write about.</p> </li> <li> <p>file_paths :  list[Path] \u2014 A list of file paths to documents that provide context for the writing.</p> </li> <li> <p>model :  str \u2014 The LiteLLM model ID to use for the agent.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The final answer from the agent, which contains the path to the saved Word document.</p> </li> </ul>"},{"location":"api/write_a_thing/cli/","title":"write_a_thing.cli","text":"write_a_thing.cli<p> source module write_a_thing.cli </p> <p>The Command-line Interface (CLI) for writing things with LLMs.</p> <p> Functions </p> <ul> <li> <p>main \u2014 Write a thing using a prompt and an optional file.</p> </li> </ul> <p> source main(prompt: str, file: list[str], model: str) \u2192 None </p> <p>Write a thing using a prompt and an optional file.</p>"},{"location":"api/write_a_thing/tools/","title":"write_a_thing.tools","text":"write_a_thing.tools<p> source module write_a_thing.tools </p> <p>The tools used by the agents.</p> <p> Functions </p> <ul> <li> <p>ask_user \u2014 Ask the user a question and return their response.</p> </li> <li> <p>load_document \u2014 Load a document from the given file path.</p> </li> <li> <p>save_as_word \u2014 Save the given Markdown content as a Word document.</p> </li> </ul> <p> source ask_user(question: str) \u2192 str </p> <p>Ask the user a question and return their response.</p> <p> Parameters </p> <ul> <li> <p>question :  str \u2014 The question to ask the user.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The user's response to the question.</p> </li> </ul> <p> source load_document(file_path: str) \u2192 str </p> <p>Load a document from the given file path.</p> <p>The <code>file_path</code> should point to an existing document file.</p> <p> Parameters </p> <ul> <li> <p>file_path :  str \u2014 The path to the document file.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The Markdown parsed content of the document.</p> </li> </ul> <p> source save_as_word(markdown_content: str, output_path: str) \u2192 str </p> <p>Save the given Markdown content as a Word document.</p> <p> Parameters </p> <ul> <li> <p>markdown_content :  str \u2014 The Markdown content to save as a Word document.</p> </li> <li> <p>output_path :  str \u2014 The path where the Word document will be saved.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The path to the saved Word document.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>FileExistsError \u2014 If the output file already exists.</p> </li> <li> <p>ValueError \u2014 If the content could not be parsed.</p> </li> </ul>"},{"location":"api/write_a_thing/writing/","title":"write_a_thing.writing","text":"write_a_thing.writing<p> source module write_a_thing.writing </p> <p>Writing things with LLMs.</p> <p> Functions </p> <ul> <li> <p>write \u2014 Write a thing using LLMs and store it as a Word document.</p> </li> </ul> <p> source write(prompt: str, file_paths: list[Path], model: str) \u2192 str </p> <p>Write a thing using LLMs and store it as a Word document.</p> <p> Parameters </p> <ul> <li> <p>prompt :  str \u2014 The prompt to write about.</p> </li> <li> <p>file_paths :  list[Path] \u2014 A list of file paths to documents that provide context for the writing.</p> </li> <li> <p>model :  str \u2014 The LiteLLM model ID to use for the agent.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The final answer from the agent, which contains the path to the saved Word document.</p> </li> </ul>"}]}